3) Measure Code Coverage on Unit Tests, Integration Tests, System Tests + Total Code Coverage. Adjust tests based on results.
4) Start writing documentation for coursework.

Things to include in this documentation:
    - Screen recorded video of CI pipeline on github.
    - Screenshot of code coverage + Raw code coverage results.


MOVE THIS OR DELETE THIS:

# Section 2: Level of Requirements - System, Integration, and Unit Tests

| **Attribute**            | **Test Used** | **Notes**                                                                                              | **Test Approach**                                                                                    |
|--------------------------|---------------|--------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| **System-Level Tests**   |               |                                                                                                        |                                                                                                      |
| Runtime Statistic        | Performance   | Ensure total execution time for daily deliveries does not exceed 60 seconds.                           | Use automated performance benchmarking tools to measure execution time under various scenarios.      |
| Load Test                | Performance   | Simulate high load with 200 concurrent orders to ensure no performance degradation.                    | Conduct stress tests with synthetic load using custom load generators.          |
| Normal Test Data         | System        | Verify no errors occur during normal operation with valid input.                                       | Execute end-to-end tests with realistic test data to verify functionality under normal conditions.   |
| Extreme Test Data        | System        | Test with maximum values (e.g., order count, no-fly zones) to ensure stability.                        | Use boundary value analysis to generate extreme test cases for input limits.                         |
| Exceptional Test Data    | System        | Verify expected errors are thrown for invalid inputs like malformed JSON or invalid coordinates.       | Perform fuzz testing to introduce malformed and invalid input data.                                  |
| No-Fly Zone Compliance   | System        | Ensure the drone avoids all specified no-fly zones, even with dynamic updates.                         | Use simulated environments with varying no-fly zone configurations and monitor drone behavior.       |
| Path Optimization        | System        | Verify the shortest path is calculated for deliveries under valid constraints.                         | This could be done using automated reasoning to prove that the A* implementation is the most optimal route.            |
| Invalid Order Handling   | System        | Confirm system rejects invalid orders based on various criteria (e.g., card number, format).           | Use equivalence partitioning to test invalid and valid order combinations.                           |
| Battery Conservation     | System        | Validate drone returns to Appleton Tower before battery depletion.                                     | Simulate delivery routes near battery limits and validate return functionality.                      |
| GeoJSON Output           | System        | Verify correct generation of GeoJSON files for drone path visualization.                               | Use automated file comparison tools to validate GeoJSON output structure and accuracy.               |
| Valid Compass Directions | System        | Ensure the drone only follows valid compass directions (16 directions + hover).                        | Generate test cases for all compass directions and verify drone behavior aligns with specifications. |
| A* Algorithm Integrity   | System        | Validate the route calculated by the A* algorithm adheres to no-fly zone and central area constraints. | Perform pathfinding verification tests against predefined scenarios with expected outputs.           |
| **Integration Tests**    |               |                                                                                                        |                                                                                                      |
| REST API Response        | Integration   | Test REST API interactions with valid and invalid data.                             | test API behavior under various scenarios.                   |
| No REST API Response       | Integration   | Test REST API interactions when we are unable to connect to the server - no internet                             | Test the project without internet connection.                   |
| Data Handling            | Integration   | Ensure proper deserialization of order, restaurant, and no-fly zone data.                              | Perform deserialization tests with JSON samples to verify data parsing accuracy.                     |
| No-Fly Zone Avoidance    | Integration   | Validate integration between `AreaSingleton` and path calculation modules.                             | Simulate routes near no-fly zones and validate compliance through log analysis.                      |
| Credit Card Validation   | Integration   | Confirm validation logic integrates with the `Order` class for card data.                              | Use parameterised tests to validate card details across various valid and invalid input cases.       |
| GeoJSON Format           | Integration   | Test JSON serialization of drone paths using `FileWriter`.                                             | Validate output format with schema validation tools for GeoJSON compliance.                          |
| Restaurant Validation    | Integration   | Ensure orders are matched correctly to participating restaurants.                                      | Test restaurant assignment with edge cases involving overlapping and ambiguous data.                 |
| FlightPathPoint Mapping  | Integration   | Verify drone movements are correctly represented in GeoJSON outputs.                                   | Visual inspection of generated paths combined with automated coordinate validation.                  |
| Route Calculation        | Integration   | Test integration between `RouteCalculator`, `LngLat`, and `CompassDirection` for route generation.     | Simulate various start and end points to validate accurate route generation.                         |
| Central Area Validation  | Integration   | Validate that `AreaSingleton` correctly loads and applies central area boundary constraints.           | Use boundary tests with varying central area configurations to ensure proper functionality.          |
| **Unit Tests**           |               |                                                                                                        |                                                                                                      |
| Credit Card Validation   | Unit          | Test regex and Luhn algorithm in `CreditCardInformation` for valid/invalid numbers.                    | Write unit tests using boundary and invalid input cases for regex and algorithm validation.          |
| Expiry Date Parsing      | Unit          | Validate correct parsing and comparison of expiry dates in `Order`.                                    | Perform unit tests with edge cases for valid and invalid expiry dates.                               |
| CVV Validation           | Unit          | Ensure CVV is exactly three numeric digits.                                                            | Use parameterised unit tests to validate numeric and non-numeric inputs.                             |
| Menu Parsing             | Unit          | Test correct deserialization of menu data in `Menu`.                                                   | Write unit tests with predefined JSON samples for menu deserialization.                              |
| Pizza Validation         | Unit          | Confirm `containsInvalidPizza` correctly identifies invalid pizzas in `Order`.                         | Use mock restaurant menus to test invalid and valid pizza combinations.                              |
| Restaurant Location      | Unit          | Validate longitude and latitude accuracy in `Restaurant.Location`.                                     | Perform unit tests with edge cases for out-of-range geographic coordinates.                          |
| Order Outcome Assignment | Unit          | Ensure `Order` assigns the correct `OrderOutcome` based on validation rules.                           | Write unit tests for all possible outcomes using equivalence partitioning.                           |
| FileWriter Outputs       | Unit          | Test JSON and GeoJSON output generation for correctness.                                               | Use snapshot testing to validate generated files against expected outputs.                           |
| Singleton Behavior       | Unit          | Verify singleton behavior of `AreaSingleton` for consistent data access.                               | Use concurrency tests to validate thread safety of the singleton implementation.                     |
| Path Angle Calculation   | Unit          | Test angle calculations in `FlightPathPoint` for accuracy.                                             | Write unit tests for all compass directions to validate angle conversions.                           |
| Order Parsing            | Unit          | Confirm deserialization of `Order` JSON into valid objects.                                            | Perform unit tests with various valid and malformed JSON samples.                                    |
| Central Area Border      | Unit          | Validate correct loading of central area data from the REST API.                                       | Write unit tests to verify parsing and storage of central area borders.                              |
| Drone Coordinate Mapping | Unit          | Test `FlightPathPoint` for correct mapping of start and end coordinates.                               | Validate coordinate calculations through unit tests for sample flight paths.                         |
| Invalid Input Handling   | Unit          | Verify exceptions are correctly thrown for invalid data in `OrderRetriever`.                           | Use mock API responses with invalid data formats to validate exception handling.                     |
| Price Validation         | Unit          | Confirm `validatePriceTotal` in `Order` checks totals against menu prices accurately.                  | Write unit tests with both undercharged and overcharged totals to validate logic.                    |
| Direction Handling       | Unit          | Validate `CompassDirection` enum for accurate direction-to-angle mapping.                              | Use parameterised tests for all compass directions to validate accuracy.                             |
| Distance Tolerance       | Unit          | Test `LngLat.closeTo` for correct distance threshold application.                                      | Write unit tests with edge cases to validate distance threshold behavior.                            |
| No-Fly Zone Check        | Unit          | Verify `LngLat.inNoFlyZone` detects entry and intersection with no-fly zones accurately.               | Use mock no-fly zones to validate detection logic with various paths.                                |
| Node Heuristic Accuracy  | Unit          | Confirm A* `Node` heuristic correctly accounts for no-fly zones and central area restrictions.         | Validate heuristic calculations with predefined scenarios in unit tests.                             |
| Route Reconstruction     | Unit          | Test `RouteCalculator.reconstructPath` for accurate path rebuilding from A* nodes.                     | Simulate path reconstruction with known inputs and verify against expected results.                  |
| Hover Handling           | Unit          | Ensure hover action (`CompassDirection.HOVER`) correctly preserves drone's location.                   | Write unit tests to validate hover behavior without position changes.                                |



TODO: MOVE THIS OR DELTE THIS:


## Testing Strategy Across the Lifecycle

### Requirements and Design
- **System Requirements:** Ensure that high-level requirements such as delivery path optimization and no-fly zone compliance are correctly defined and traceable to tests.
- **Performance and Scalability:** Performance benchmarks and load testing were designed based on early requirements to ensure scalability.
- **Security:** Requirements related to input validation and robustness against malformed data were addressed in this phase.

### Implementation
- **Unit Testing:** Unit tests were created for individual methods such as `Order.validateOrder` and `LngLat.distanceTo`. These tests validate core functionalities and edge cases.
- **Integration Testing:** Integration tests focus on interactions between modules like `OrderRetriever` and the REST API or `RouteCalculator` and `AreaSingleton`.
- **Mutation Testing:** During implementation, mutation testing was applied to assess the robustness of unit tests and ensure comprehensive coverage.

### Testing and Debugging
- **System Testing:** High-level functionalities, such as load handling and no-fly zone avoidance, were validated using synthetic test scenarios.
- **Fuzz Testing:** Introduced malformed inputs to assess the robustness of the system against unexpected data.
- **Regression Testing:** Ensured that new code additions or fixes did not break existing functionality.

### Deployment
- **End-to-End Testing:** Validated that the final system meets all functional requirements and works seamlessly from order retrieval to delivery.
- **Exploratory Testing:** Conducted exploratory testing to identify rare edge cases or systemic issues not covered by formal test cases.

---

## How Testing Addressed Evolving Needs
### Example: Addition of Timestamped Logging
When the requirement for timestamped logging was identified to improve debugging, additional unit tests were added to validate time format and accuracy. Integration tests ensured timestamps propagated correctly through the system.

### Example: Handling High Order Volumes
The original system tests focused on a moderate number of orders. When performance requirements shifted to handle 200 simultaneous orders, the load tests were updated, and additional integration tests were introduced to ensure seamless API communication under stress.

---

## Limitations and Future Considerations
1. **Static Test Plan:** Unlike TDD, the waterfall approach resulted in limited adaptability of the test set to emerging functionality.
2. **Exploratory Gaps:** While exploratory testing mitigated this, some edge cases (e.g., overlapping no-fly zones creating impassable paths) were discovered late.
3. **Limited Monitoring:** Instrumentation was not included in early stages, reducing visibility into performance issues during development.

---

## Diagram Request
Please generate a diagram illustrating the mapping of test types (unit, integration, system) to the software lifecycle stages (requirements, implementation, testing, deployment). Show example tests and their relationships to lifecycle phases.

# Section 2: Evaluation of the Quality of the Test Plan

### Strengths
1. **Comprehensive Coverage:** The test plan provides a broad spectrum of tests, including unit, integration, system, and exploratory testing, ensuring multiple aspects of the system are validated.
2. **Alignment with Lifecycle:** Mapping tests to lifecycle phases ensures logical progression and accountability for each stage of development.
3. **Stress and Performance Testing:** Load and performance tests effectively address scalability and runtime requirements.

### Weaknesses
1. **Instrumentation Gaps:** Limited use of instrumentation, such as diagnostic logs or assertions, reduced the ability to monitor runtime behaviour and pinpoint faults dynamically.
2. **Reactive Approach:** The post-development creation of the test plan limited its adaptability to emerging requirements.
3. **Limited Security Testing:** While input validation was robust, additional tests for injection vulnerabilities or other security risks could have been beneficial.

### Potential Omissions or Vulnerabilities
- **Rare Edge Cases:** Overlapping no-fly zones or unexpected API behaviour could still result in unhandled scenarios.
- **Real-Time Monitoring:** Absence of runtime monitoring tools reduced visibility into operational issues, such as delays in delivery calculations.

### Adequacy of the Plan
The test plan is well-suited for validating the PizzaDronz project’s core requirements and functionality. However, addressing instrumentation gaps and adding dynamic monitoring could enhance future test plans. The outlined recommendations ensure the plan evolves effectively to meet high-quality standards.

---

## Instrumentation of the Code

### Instrumentation Justification
The PizzaDronz project did not include code instrumentation. This decision was based on the project requirements, which emphasised thorough pre-deployment testing over runtime monitoring. The nature of the requirements and the post-development testing approach made instrumentation unnecessary.

### Adequacy of the Approach
1. **No Immediate Need for Instrumentation:** Comprehensive unit, integration, and system tests were sufficient to identify and address most issues during pre-deployment testing.
2. **Alignment with Requirements:** The lack of instrumentation did not compromise the ability to meet functional or non-functional requirements.

### Limitations
1. **Reduced Runtime Insights:** Without runtime logs or diagnostic outputs, troubleshooting in live scenarios could be more challenging.
2. **Missed Opportunities for Monitoring:** Instrumentation could have provided valuable insights into performance bottlenecks or rare runtime issues.

### Recommendations
While not necessary for this project, future iterations should incorporate basic instrumentation such as diagnostic logging and assertions. These additions would enhance visibility, aid in real-time fault detection, and improve debugging during maintenance or scaling efforts.
